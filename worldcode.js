Q=3
function onPlayerJoin(id){
 api.setWalkThroughType(id, "Invisible Solid")
}
/**
 * Developed by Chesplate (or MrChestplate).
 * Youtube Channel: @Javeline947.
 *
 * Copyright (C) 2026 Chesplate
 * Licensed under the GNU General Public License v3.0
 *
 * @author Chesplate
 * @license GPL-3.0
 */
const OPS_PER_TICK=250,shadowState={lightSources:[],areaA:null,areaB:null,visualizeLight:!0,stepSize:.25,jobs:[],particleRefreshTicker:0},errStyle={color:"#ff5555"},succStyle={color:"#55ff55"},infoStyle={color:"#aaaaaa"},cmdStyle={color:"#ffff55"},algoStyle={color:"#ffaa00",fontWeight:"bold"},creditStyle={color:"#55ffff",fontWeight:"bold"};function findLightIndexAt(t){const e=t.map(Math.floor);return shadowState.lightSources.findIndex((t=>{const s=t.map(Math.floor);return s[0]===e[0]&&s[1]===e[1]&&s[2]===e[2]}))}function onPlayerClick(t,e){const s=e=>api.sendMessage(t,e);switch(api.getHeldItem(t).name){case"Active Radar":if(0===shadowState.lightSources.length)return s([{str:"⚠️ Error: No Light Source defined. Use the Master Rod first.",style:errStyle}]);if(!shadowState.areaA||!shadowState.areaB)return s([{str:"⚠️ Error: Render area not defined. Use the Tangle Resistant Rod first.",style:errStyle}]);s([{str:`Starting shadow render for ${shadowState.lightSources.length} light(s) using Algo C...`,style:infoStyle}]),startJob(t,"SHADOW",shadowState.areaA,shadowState.areaB,shadowState.lightSources,"C");break;case"Inactive Radar":if(!shadowState.areaA||!shadowState.areaB)return s([{str:"⚠️ Error: Render area not defined. Use the Tangle Resistant Rod first.",style:errStyle}]);s([{str:"Clearing shadows in the defined area...",style:infoStyle}]),startJob(t,"CLEAR",shadowState.areaA,shadowState.areaB,null);break;case"Master Rod":const a=api.getPlayerTargetInfo(t);if(e){let e=-1;if(a){const t=findLightIndexAt(a.position);-1!==t&&(e=t)}if(-1===e){const s=api.getPlayerFacingInfo(t).camPos,a=shadowState.lightSources.map(((t,e)=>({index:e,dist:Math.sqrt((t[0]-s[0])**2+(t[1]-s[1])**2+(t[2]-s[2])**2)}))).filter((t=>t.dist<=1));a.length>0&&(a.sort(((t,e)=>t.dist-e.dist)),e=a[0].index)}-1!==e?(shadowState.lightSources.splice(e,1),s([{str:`Light source removed (${shadowState.lightSources.length} total). Particle will fade.`,style:succStyle}])):s([{str:"No light source found at the targeted block or nearby to remove.",style:infoStyle}])}else{let e;if(a&&"Air"!==api.getBlock(...a.position)?(e=a.position.map((t=>t+.5)),s([{str:"Light source set to targeted block.",style:succStyle}])):(e=api.getPlayerFacingInfo(t).camPos,s([{str:"No block targeted. Light source set to camera position.",style:succStyle}])),-1!==findLightIndexAt(e))return s([{str:"A light source already exists at this block.",style:infoStyle}]);shadowState.lightSources.push(e),shadowState.visualizeLight&&spawnLightMarker(e),s([{str:`Light source added (${shadowState.lightSources.length} total).`,style:succStyle}])}break;case"Tangle Resistant Rod":const r=api.getPlayerTargetInfo(t);let o;const l=e?"Maximum":"Minimum",i=e?"areaB":"areaA";r&&"Air"!==api.getBlock(...r.position)?(o=r.position,s([{str:`${l} position set to targeted block.`,style:succStyle}])):(o=api.getPlayerFacingInfo(t).camPos.map(Math.floor),s([{str:`No block targeted. ${l} position set to camera position.`,style:succStyle}])),shadowState[i]=o,s([{str:` -> [${o[0]}, ${o[1]}, ${o[2]}]`,style:cmdStyle}])}}function playerCommand(t,e){const s=e.split(" "),a=s[0],r=e=>api.sendMessage(t,e);try{switch(a){case"getShadowTools":return api.giveItem(t,"Master Rod",1,{customDisplayName:"Master Rod",customDescription:"Left-click to add a light, Right-click to remove"}),api.giveItem(t,"Tangle Resistant Rod",1,{customDisplayName:"Tangle Resistant Rod",customDescription:"Left-click to set Min pos, Right-click to set Max pos"}),api.giveItem(t,"Active Radar",1,{customDisplayName:"Active Radar",customDescription:"Starts Shadow rendering (Algorithm C)"}),api.giveItem(t,"Inactive Radar",1,{customDisplayName:"Inactive Radar",customDescription:"Clears rendered shadows in the area"}),r([{str:"Shadow utility items granted!",style:succStyle}]),!0;case"setLightSource":let e,a,o;if(1===s.length){const s=api.getPlayerFacingInfo(t).camPos;e=s[0],a=s[1],o=s[2]}else{if(4!==s.length)return r([{str:"Usage: setLightSource [x] [y] [z] (or leave empty for cam)",style:errStyle}]),!0;if(e=parseFloat(s[1]),a=parseFloat(s[2]),o=parseFloat(s[3]),isNaN(e)||isNaN(a)||isNaN(o))throw"Invalid coordinates."}return shadowState.lightSources=[[e,a,o]],r([{str:`All lights cleared. New light source set to: [${e.toFixed(1)}, ${a.toFixed(1)}, ${o.toFixed(1)}]`,style:succStyle}]),shadowState.visualizeLight&&spawnLightMarker(shadowState.lightSources[0]),!0;case"clearLightSources":return shadowState.lightSources=[],r([{str:"All light sources cleared.",style:succStyle}]),!0;case"visualizeLight":return shadowState.visualizeLight=!0,shadowState.lightSources.forEach(spawnLightMarker),r([{str:"Light visualization ENABLED.",style:succStyle}]),!0;case"hideLight":return shadowState.visualizeLight=!1,r([{str:"Light visualization DISABLED. (Note: Existing particles will fade away)",style:infoStyle}]),!0;case"setStepSize":if(2!==s.length)return r([{str:"Usage: setStepSize [size]",style:errStyle}]);const l=parseFloat(s[1]);return isNaN(l)||l<=.05||l>1?r([{str:"Error: Step size must be a number between 0.05 and 1.0",style:errStyle}]):(shadowState.stepSize=l,r([{str:"Algorithm C step size set to ",style:succStyle},{str:String(l),style:cmdStyle}]),!0);case"setRenderArea":if(7!==s.length)return r([{str:"Usage: setRenderArea [x] [y] [z] [x1] [y1] [z1]",style:errStyle}]);const i=parseInt(s[1]),n=parseInt(s[2]),c=parseInt(s[3]),h=parseInt(s[4]),d=parseInt(s[5]),S=parseInt(s[6]);if(isNaN(i)||isNaN(h))throw"Coordinates must be numbers.";return shadowState.areaA=[i,n,c],shadowState.areaB=[h,d,S],r([{str:"Render Area set: ",style:succStyle},{str:`[${i},${n},${c}]`,style:cmdStyle},{str:" to ",style:succStyle},{str:`[${h},${d},${S}]`,style:cmdStyle}]),!0;case"renderShadows":if(0===shadowState.lightSources.length)return r([{str:"⚠️ Error: No Light Source defined. Use setLightSource first.",style:errStyle}]);if(!shadowState.areaA||!shadowState.areaB)return r([{str:"FATAL ERROR: NULL_CONSTRAINT_EXCEPTION.",style:{color:"red",fontWeight:"bold"}},{str:"\nSystem cannot calculate infinity. Please define bounds using: ",style:errStyle},{str:"setRenderArea",style:cmdStyle}]);let y="C";if(s[1]){const t=s[1].toUpperCase();"F"===t?y="F":"E"===t&&(y="E")}return r([{str:`Calculating shadows for ${shadowState.lightSources.length} light(s) using Algo ${y}...`,style:infoStyle}]),startJob(t,"SHADOW",shadowState.areaA,shadowState.areaB,shadowState.lightSources,y),!0;case"clearShadows":return shadowState.areaA&&shadowState.areaB?(r([{str:"Clearing shadows in area...",style:infoStyle}]),startJob(t,"CLEAR",shadowState.areaA,shadowState.areaB,null),!0):r([{str:"Error: No area defined to clear.",style:errStyle}]);case"help":const g={color:"#55ffff"};return r([{str:"--- Shadow System Help ---",style:{fontWeight:"bold",color:"white"}},{str:"\n\n--- Commands ---",style:{fontWeight:"bold",color:"white"}},{str:"\n getShadowTools",style:g},{str:" : Get utility items",style:infoStyle},{str:"\n setLightSource [x y z]",style:g},{str:" : Replaces all lights with one",style:infoStyle},{str:"\n clearLightSources",style:g},{str:" : Removes all light sources",style:infoStyle},{str:"\n setRenderArea x1 y1 z1 x2 y2 z2",style:g},{str:" : Define the calculation box",style:infoStyle},{str:"\n setStepSize [size]",style:g},{str:" : Set Algo C accuracy (0.1-1.0)",style:infoStyle},{str:"\n renderShadows [C/E/F]",style:g},{str:" : Calculate shadows (C is default)",style:infoStyle},{str:"\n clearShadows",style:g},{str:" : Remove shadows in the area",style:infoStyle},{str:"\n visualizeLight / hideLight",style:g},{str:" : Toggle light particles",style:infoStyle},{str:"\n\n--- Algorithms ---",style:{fontWeight:"bold",color:"white"}},{str:"\n Algo C",style:algoStyle},{str:" : Ray Marching (Default). Uses 'setStepSize' to balance speed/quality.",style:infoStyle},{str:"\n Algo E",style:algoStyle},{str:" : Bresenham's Line Algo. Fast integer math, but may leak at corners.",style:infoStyle},{str:"\n Algo F",style:algoStyle},{str:" : 3D DDA. Watertight, fastest, and best quality.",style:infoStyle}]),r([{str:"\n Developed by Chesplate (or MrChestplate)",style:creditStyle},{str:"\n Youtube Channel: @Javeline947",style:cmdStyle},{str:"\n\n Copyright (C) 2026 Chesplate",style:infoStyle},{str:"\n Licensed under the GNU General Public License v3.0",style:infoStyle},{str:"\n\n @author Chesplate",style:infoStyle},{str:"\n @license GPL-3.0",style:infoStyle}]),!0}}catch(t){return r([{str:"Command Error: "+t,style:errStyle}]),!0}return!1}function startJob(t,e,s,a,r,o="C"){const l=[Math.min(s[0],a[0]),Math.min(s[1],a[1]),Math.min(s[2],a[2])],i=[Math.max(s[0],a[0]),Math.max(s[1],a[1]),Math.max(s[2],a[2])],n=i[0]-l[0]+1,c=i[1]-l[1]+1,h=i[2]-l[2]+1,d=n*c*h;shadowState.jobs=[{id:t,type:e,algo:o,min:l,max:i,lights:r,x:l[0],y:l[1],z:l[2],totalBlocks:d,dx:n,dy:c,dz:h,nextReport:10}]}function tick(){shadowState.visualizeLight&&++shadowState.particleRefreshTicker>=100&&(shadowState.particleRefreshTicker=0,shadowState.lightSources.forEach(spawnLightMarker));let t=shadowState.jobs;if(!t||0===t.length)return;let e=t[0],s=0;for(;s++<250;){let s=e.x,a=e.y,r=e.z;if("SHADOW"===e.type?processShadowBlock(s,a,r,e.lights,e.algo,shadowState.stepSize):processClearBlock(s,a,r),++e.z>e.max[2]&&(e.z=e.min[2],++e.y>e.max[1]&&(e.y=e.min[1],++e.x>e.max[0])))return t.shift(),api.sendMessage(e.id,[{str:("SHADOW"===e.type?"Shadow rendering":"Clearing")+" complete!",style:succStyle}]),void console.log("Job Finished.")}let a=(e.x-e.min[0])*e.dy*e.dz,r=(e.y-e.min[1])*e.dz,o=e.z-e.min[2],l=Math.floor((a+r+o)/e.totalBlocks*100);l>=e.nextReport&&(api.sendMessage(e.id,[{str:`${"SHADOW"===e.type?"Rendering shadows":"Clearing"}... ${l}% complete`,style:infoStyle}]),e.nextReport+=10)}function processShadowBlock(t,e,s,a,r,o){let l=api.getBlock,i=api.setBlock,n="Invisible Solid",c="Air",h=l(t,e,s),d=e+1,S=l(t,d,s);if(h===c||h===n||S!==c&&S!==n)return;let y=!1,g=new Set;for(const e of a){let a;if(a="F"===r?raycastForShadowF([t,d,s],e):"E"===r?raycastForShadowE([t,d,s],e):raycastForShadowC([t,d,s],e,o),!a.hit){y=!0;break}a.wallPos&&g.add(a.wallPos.join(","))}if(y)S===n&&i(t,d,s,c);else{S!==n&&i(t,d,s,n);for(const e of g){let a=e.split(",").map(Number);(a[0]!==t||a[1]!==d||a[2]!==s)&&l(...a)===c&&i(...a,n)}}}function processClearBlock(t,e,s){"Invisible Solid"===api.getBlock(t,e,s)&&api.setBlock(t,e,s,"Air")}function raycastForShadowC(t,e,s){let a=api.getBlock,r=Math.floor,o=e[0]-t[0],l=e[1]-t[1],i=e[2]-t[2],n=Math.sqrt(o*o+l*l+i*i);if(n<1)return{hit:!1,wallPos:null};let c=o/n,h=l/n,d=i/n,S=n/s,y=t[0],g=t[1],u=t[2],f=r(y),p=r(g),w=r(u);for(let t=1;t<S;t++){let e=r(y+c*t*s),o=r(g+h*t*s),l=r(u+d*t*s);if(e!==f||o!==p||l!==w){let t=a(e,o,l);if("Air"!==t&&"Invisible Solid"!==t)return{hit:!0,wallPos:[f,p,w]};f=e,p=o,w=l}}return{hit:!1,wallPos:null}}function raycastForShadowE(t,e){let s,a,r=api.getBlock,o=t[0],l=t[1],i=t[2],n=Math.floor(e[0]),c=Math.floor(e[1]),h=Math.floor(e[2]),d=Math.abs(n-o),S=Math.abs(c-l),y=Math.abs(h-i),g=n>o?1:-1,u=c>l?1:-1,f=h>i?1:-1;if(d>=S&&d>=y)for(s=2*S-d,a=2*y-d;o!==n;){o+=g,s>=0&&(l+=u,s-=2*d),a>=0&&(i+=f,a-=2*d),s+=2*S,a+=2*y;let t=r(o,l,i);if("Air"!==t&&"Invisible Solid"!==t&&"LightSource"!==t)return{hit:!0,wallPos:[o-g,l,i]}}else if(S>=d&&S>=y)for(s=2*d-S,a=2*y-S;l!==c;){l+=u,s>=0&&(o+=g,s-=2*S),a>=0&&(i+=f,a-=2*S),s+=2*d,a+=2*y;let t=r(o,l,i);if("Air"!==t&&"Invisible Solid"!==t&&"LightSource"!==t)return{hit:!0,wallPos:[o,l-u,i]}}else for(s=2*S-y,a=2*d-y;i!==h;){i+=f,s>=0&&(l+=u,s-=2*y),a>=0&&(o+=g,a-=2*y),s+=2*S,a+=2*d;let t=r(o,l,i);if("Air"!==t&&"Invisible Solid"!==t&&"LightSource"!==t)return{hit:!0,wallPos:[o,l,i-f]}}return{hit:!1,wallPos:null}}function raycastForShadowF(t,e){let s=api.getBlock,a=Math.floor,r=a(t[0]),o=a(t[1]),l=a(t[2]),i=a(e[0]),n=a(e[1]),c=a(e[2]),h=e[0]-t[0],d=e[1]-t[1],S=e[2]-t[2],y=h>0?1:-1,g=d>0?1:-1,u=S>0?1:-1,f=0===h?1e30:Math.abs(1/h),p=0===d?1e30:Math.abs(1/d),w=0===S?1e30:Math.abs(1/S),m=f*(h>0?a(t[0])+1-t[0]:t[0]-a(t[0])),b=p*(d>0?a(t[1])+1-t[1]:t[1]-a(t[1])),A=w*(S>0?a(t[2])+1-t[2]:t[2]-a(t[2])),L=r,R=o,M=l,C=0;for(;(r!==i||o!==n||l!==c)&&C++<300;){m<b?m<A?(r+=y,m+=f):(l+=u,A+=w):b<A?(o+=g,b+=p):(l+=u,A+=w);let t=s(r,o,l);if("Air"!==t&&"Invisible Solid"!==t&&"LightSource"!==t)return{hit:!0,wallPos:[L,R,M]};L=r,R=o,M=l}return{hit:!1,wallPos:null}}function spawnLightMarker(t){api.playParticleEffect({pos1:t,pos2:[t[0]+.1,t[1]+.1,t[2]+.1],dir1:[0,0,0],dir2:[0,0,0],texture:"bubble",minLifeTime:6,maxLifeTime:6,minEmitPower:0,maxEmitPower:0,minSize:.5,maxSize:.5,manualEmitCount:1,gravity:[0,0,0],colorGradients:[{timeFraction:0,minColor:[255,255,0,1],maxColor:[253,255,200,1]}],velocityGradients:[{timeFraction:0,factor:0,factor2:0}],blendMode:1})}

